<header>
    基础语法
</header>
<h2>
    控制语法
</h2>
<p>
    break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。
</p>
<p>
    continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环。
</p>
<h3>
    if条件控制
</h3>
<pre tag="python">
if 表达式:
语句
if 表达式:
    语句
elif 表达式:
    语句
else:
    语句
</pre>
<h3>
    while循环
</h3>
<pre tag="python">
while 判断条件:
    语句
else:
    语句
</pre>
<p class="warn">
    Python中没有do..while循环
</p>
<h3>
    for语句
</h3>
<pre tag="python">
for &lt;variable&gt; in &lt;sequence&gt;:
    &lt;statements&gt;
else:
    &lt;statements&gt;
</pre>
<h2>
    迭代器与生成器
</h2>
<h3>
    迭代器
</h3>
<p>
    迭代器是什么东西？哈哈，有没有想起java中集合的方法iterator()返回迭代器？是的，就是类似这个的存在。
</p>
<p>
    迭代器有两个基本的方法：iter() 和 next()，这点也很类似java（字符串，列表或元组对象都可用iter()方法创建迭代器对象）。
</p>
<p>
    下面先简单演示一下这两个方法的用法：
</p>
<pre tag="python">
list=['中国','美国','俄罗斯','埃塞俄比亚']

#1.使用iter()方法获取迭代器对象
it = iter(list) 

#2.使用next()方法依次获取数据
print (next(it)) #打印结果是'中国'
print (next(it)) #打印结果是'美国'
</pre>
<p>
    上面的例子应该已经明白这两个方法的用法了，使用iter()方法获取迭代器对象，再用next(it)方法依次获取集合的数据。
</p>
<p>
    当然，到末尾了已经没有可以取的数据的时候，再次调用会抛出异常，因此我们可以借助这个来实现迭代全部的数据，如下：
</p>
<pre tag="python">
list=['中国','美国','俄罗斯','埃塞俄比亚']

it = iter(list)  

flag=True; 

while flag:

    try:
        print (next(it))
        
    except StopIteration:
        print ('迭代结束了',end='\n')
        flag=False
</pre>
<p>
    除此之外，使用for可以实现类似的效果，如下：
</p>
<pre tag="python">
list=['中国','美国','俄罗斯','埃塞俄比亚']

it = iter(list)

for x in it: 
    print (x, end=" ") #'中国','美国','俄罗斯','埃塞俄比亚'
</pre>
<p>
    因此，迭代全部的数据肯定不是迭代器存在的全部意义，更多的时候，你可以把它看成一个管理一列数据的对象，需要的时候告诉他一下，他就会给你下一个数据，不像for循环那样一下子迭代结束，你可以在任何需要的时候获取下一个数据。
</p>
<p>
    记住这一个特点，特别是在设计算法或者模式的时候，会很有用的（当然，具体用好他从来都是经验的事情，祝你好运）。
</p>
<h3>
    生成器
</h3>
<p>
    TS或者ES6+有所了解的人应该都知道yield函数，基本上和这里的差不多用法。
</p>
<p>
    在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行 next()方法时从当前位置继续运行。
</p>
<p>
    上面的说法可能有点不好理解，ok，下面用大白话说一下：
</p>
<p>
    生成器就是一个可以自定义一个生成迭代器对象函数的概念，生成的迭代器对象每次被询问返回下一个数据的时候，自定义的如果返回，使用的就是yield函数，先看下下面的例子：
</p>
<pre tag="python">
#定义一下可以生成迭代器对象的函数，类似上面例子中的iter()方法
def generatorDemo(array):
    index=0
    while(index&lt;len(array)):
        #你每次调用next(it)的时候，就是这里返回给你的数据
        yield array[index]
        index=index+1

#用上面的迭代器对象生成函数生成一个迭代器对象
it=generatorDemo(['中国','美国','俄罗斯','埃塞俄比亚'])
 
#下面就是和之前一样使用
flag=True
while flag:
    try:
        print (next(it), end=" ")
    except StopIteration:
        flag=False

#执行结果：中国 美国 俄罗斯 埃塞俄比亚 
</pre>
<p>
    因此，你可以从两个角度来理解生成器：
</p>
<ul>
    <li>
        一个和迭代器配合使用的迭代器对象生成方法；
    </li>
    <li>
        更本质的理解：yield类似return，可以返回数据，不过不同的是，可以多次返回数据，调用一下返回一下，再次调用返回下一个yield定义返回数据的地方，就如同上面的例子，直到yield语句全部完毕再次调用会抛出错误。
    </li>
</ul>
<p>
    如果你问我什么时候使用他，这具体看业务需求，就好比if语句一样，他就在那里，需要用的时候可以记起来他，就够了。
</p>
<h2>
    函数
</h2>
<p>
    具体就不用多说明了，直接给出定义，然后说几个重要的问题。
</p>
<pre tag="python">
def 函数名（参数列表）:
    函数体
</pre>
<h3>
    参数传递
</h3>
<p>
    在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。
</p>
<p>
    函数中传递参数的时候，不可更改的对象和可以修改的对象在操作影响上是有很大区别的，用一句话说明的话就是：不可更改的对象类似传递的是值，可以修改的对象传递的是'指针'，也就是引用传递，应该可以感受出来区别了吧。
</p>
<p>
    python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。
</p>
<h3>
    参数类型
</h3>
<p>
    参数有四种，具体的很多和ES很像，不过在第一点上和ES区别很大，下面来简单说明一下：
</p>
<h4>
    必需参数
</h4>
<p>
    就是你定义函数的时候，定义了几个参数，调用的时候就要传递几个，当然是普通定义方法，不包括下面的不定长参数，这点ES就很随意了。
</p>
<h4>
    关键字参数
</h4>
<p>
    举个例子，比如你定义了一个函数有两个参数age和name，函数名称是getInfo，正常调用是依次传递参数：getInfo(7,'zxl20070701')，当然你可以不这样，你还可以这样：
</p>
<pre tag="python">
    getInfo(name='zxl20070701',age=7)；
</pre>
<h4>
    默认参数
</h4>
<p>
    这个就和ES6差不多意思，举例，定义函数时（没有写全，值写函数头部）：
</p>
<pre tag="python">
    getInfo(age,name='默认名称');
</pre>
<h4>
    不定长参数
</h4>
<p>
    定义方法：getInfo(age,name,*vartuple)，这样多传递的数据就全部在vartuple中，调用前它是一个空元组。
</p>